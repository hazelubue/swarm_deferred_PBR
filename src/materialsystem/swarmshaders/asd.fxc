//===================== Copyright (c) Valve Corporation. ======================
//
// Skydome Pixel Shader with Atmosphere + Volumetric Clouds + Stars + Sun
//
// STATIC: "CONVERT_TO_SRGB" "0..0"
// DYNAMIC: "RENDER_SKY"     "0..1"
// DYNAMIC: "ENABLE_STARS"   "0..1"
// DYNAMIC: "ENABLE_SUN"   "0..1"
//=============================================================================

#include "common_flashlight_fxc.h"
#include "shader_constant_register_map.h"



#define PI 3.14159265
#define iSteps 2
#define JSTEPS 2

#define CLOUD_MAX_HEIGHT 30


// -- Combo define
#if ENABLE_STARS
#define STARFIELD_ENABLED 1
#else
#define STARFIELD_ENABLED 0
#endif

//--------------------------------------
// Registers
//--------------------------------------
const float4 g_DiffuseModulation : register(PSREG_DIFFUSE_MODULATION);
const float4 g_ShadowTweaks : register(PSREG_ENVMAP_TINT__SHADOW_TWEAKS);
const float4 g_FogParams : register(PSREG_FOG_PARAMS);
const float4 g_FlashlightAttenuation : register(PSREG_FLASHLIGHT_ATTENUATION);
const float4 g_FlashlightPos_RimBoost : register(PSREG_FLASHLIGHT_POSITION_RIM_BOOST);
const float4x4 g_FlashlightWorldToTexture : register(PSREG_FLASHLIGHT_TO_WORLD_TEXTURE);

uniform sampler2D LUTSample : register(s0);

float g_Thickness : register(c4);
float g_Coverage : register(c5);
float4 g_SunPos : register(c6); // .xyz = sun direction (should be normalized), .w = sun intensity
float4 g_WindSpeed : register(c7);
float g_Time : register(c8);
float jSteps_F : register(c9);
float g_CloudSplits : register(c10);
const float2 g_vecfullscreentexel : register(c11);
float g_RenderAurora : register(c12);
float g_SunIntensity : register(c13);
//float CLOUD_MAX_HEIGHT : register(c14);
//float CLOUD_MIN_HEIGHT : register(c15);
static const float CLOUD_BASE = 1500.0; // bottom of clouds
static const float CLOUD_TOP = 3500.0; // top of clouds

const float4 g_GlobalLightDir : register(c14); // xyz = direction, w = has shadow
const float4 g_GlobalLightDiffuse : register(c15); // xyz = diffuse color

//--------------------------------------
// Input/Output
//--------------------------------------
struct PS_INPUT
{
    float2 baseTexCoord : TEXCOORD0;
    float4 lightAtten : TEXCOORD1;
    float3 worldNormal : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
    float3 projPos : TEXCOORD4;
    float3 modelPos : TEXCOORD5;
};

struct PS_OUTPUT
{
    float4 vColor_0 : COLOR0;
    float4 vColor_1 : COLOR1;
    float4 vColor_2 : COLOR2;
    float4 vColor_3 : COLOR3;
};

float2x2 mm2(in float a)
{
    float c = cos(a), s = sin(a);
    return float2x2(c, s, -s, c);
}
float2x2 m2 = float2x2(0.95534, 0.29552, -0.29552, 0.95534);
float tri(in float x)
{
    return clamp(abs(frac(x) - .5), 0.01, 0.49);
}
float2 tri2(in float2 p)
{
    return float2(tri(p.x) + tri(p.y), tri(p.y + tri(p.x)));
}

//--------------------------------------
// Utility: Bayer 4x4 Dither
//--------------------------------------
static const float bayerMatrix4x4[16] =
{
    0.0 / 16.0, 8.0 / 16.0, 2.0 / 16.0, 10.0 / 16.0,
    12.0 / 16.0, 4.0 / 16.0, 14.0 / 16.0, 6.0 / 16.0,
    3.0 / 16.0, 11.0 / 16.0, 1.0 / 16.0, 9.0 / 16.0,
    15.0 / 16.0, 7.0 / 16.0, 13.0 / 16.0, 5.0 / 16.0
};

float3 ApplyDither(float3 color, float2 screenPos)
{
    int x = (int) screenPos.x % 4;
    int y = (int) screenPos.y % 4;
    float threshold = bayerMatrix4x4[y * 4 + x];
    float ditherAmount = 1.0 / 255.0;
    float f = ditherAmount * threshold;
    return saturate(color + f);
}

//--------------------------------------
// Noise + FBM
//--------------------------------------
float hash_iq(float n)
{
    return frac(sin(n) * 753.5453123);
}

float noise_iq3(float3 x)
{
    float3 p = floor(x), f = frac(x);
    f = f * f * (3.0 - 2.0 * f);
    float n = p.x + p.y * 157.0 + 113.0 * p.z;

    return lerp(
        lerp(lerp(hash_iq(n), hash_iq(n + 1.0), f.x),
             lerp(hash_iq(n + 157), hash_iq(n + 158), f.x), f.y),
        lerp(lerp(hash_iq(n + 113), hash_iq(n + 114), f.x),
             lerp(hash_iq(n + 270), hash_iq(n + 271), f.x), f.y),
        f.z
    );
}

float fbm3(float3 p)
{
    float v = 0.0, amp = 0.5;
    for (int i = 0; i < 5; i++)
    {
        v += amp * noise_iq3(p);
        p *= 2.0;
        amp *= 0.5;
    }
    return v;
}

float triNoise2d(in float2 p, float spd)
{
    float z = 1.8;
    float z2 = 2.5;
    float rz = 0.;
    p = mul(mm2(p.x * 0.06), p);
    float2 bp = p;
    for (float i = 0.; i < 5.; i++)
    {
        float2 dg = tri2(bp * 1.85) * .75;
        dg = mul(mm2(g_Time * spd), dg);
        p -= dg / z2;

        bp *= 1.3;
        z2 *= .45;
        z *= .42;
        p *= 1.21 + (rz - 1.0) * .02;
        
        rz += tri(p.x + tri(p.y)) * z;
        p = mul(-m2, p);
    }
    return clamp(1. / pow(rz * 29., 1.3), 0., .55);
}

float hash21(in float2 n)
{
    return frac(sin(dot(n, float2(12.9898, 4.1414))) * 43758.5453);
}

float4 aurora(float3 ro, float3 rd, float2 UV)
{
    float4 col = float4(0.0, 0.0, 0.0, 0.0);
    float4 avgCol = float4(0.0, 0.0, 0.0, 0.0);
    
    for (float i = 0.; i < 50.; i++)
    {
        float of = 0.006 * hash21(UV.xy) * smoothstep(0., 15., i);
        float pt = ((.8 + pow(i, 1.4) * .002) - ro.y) / (rd.y * 2. + 0.4);
        pt -= of;
        float3 bpos = ro + pt * rd;
        float2 p = bpos.zx;
        float rzt = triNoise2d(p, 0.06);
        float4 col2 = float4(0, 0, 0, rzt);
        col2.rgb = (sin(1. - float3(2.15, -.5, 1.2) + i * 0.043) * 0.5 + 0.5) * rzt;
        avgCol = lerp(avgCol, col2, .5);
        col += avgCol * exp2(-i * 0.065 - 2.5) * smoothstep(0., 5., i);
        
    }
    
    col *= (clamp(rd.y * 15. + .4, 0., 1.));
    
    
    //return clamp(pow(col,float4(1.3))*1.5,0.,1.);
    //return clamp(pow(col,float4(1.7))*2.,0.,1.);
    //return clamp(pow(col,float4(1.5))*2.5,0.,1.);
    //return clamp(pow(col,float4(1.8))*1.5,0.,1.);
    
    //return smoothstep(0.,1.1,pow(col,float4(1.))*1.5);
    return col * 1.8;
    //return pow(col,float4(1.))*2.
}


//--------------------------------------
// Atmosphere
//--------------------------------------
float2 rsi(float3 r0, float3 rd, float sr)
{
    float a = dot(rd, rd);
    float b = 2.0 * dot(rd, r0);
    float c = dot(r0, r0) - sr * sr;
    float d = b * b - 4.0 * a * c;
    if (d < 0.0)
        return float2(1e5, -1e5);
    return float2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));
}

float3 atmosphere(
    float3 r, float3 r0, float3 pSun, float iSun,
    float rPlanet, float rAtmos, float3 kRlh, float kMie,
    float shRlh, float shMie, float g)
{
    pSun = normalize(pSun);
    r = normalize(r);

    float2 p = rsi(r0, r, rAtmos);
    if (p.x > p.y)
        return float3(0, 0, 0);
    p.y = min(p.y, rsi(r0, r, rPlanet).x);
    float iStepSize = (p.y - p.x) / float(iSteps);

    float3 totalRlh = 0, totalMie = 0;
    float iOdRlh = 0, iOdMie = 0;
    float mu = dot(r, pSun), mumu = mu * mu;
    float gg = g * g;
    float pRlh = 3.0 / (16.0 * PI) * (1.0 + mumu);
    float pMie = 3.0 / (8.0 * PI) * ((1.0 - gg) * (mumu + 1.0)) /
                 (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg));

    float iTime = 0.0;
    for (int i = 0; i < iSteps; i++)
    {
        float3 iPos = r0 + r * (iTime + iStepSize * 0.5);
        float iHeight = length(iPos) - rPlanet;
        float odRlh = exp(-iHeight / shRlh) * iStepSize;
        float odMie = exp(-iHeight / shMie) * iStepSize;
        iOdRlh += odRlh;
        iOdMie += odMie;

        float jStepSize = rsi(iPos, pSun, rAtmos).y / float(JSTEPS);
        float jOdRlh = 0, jOdMie = 0, jTime = 0;

        for (int j = 0; j < JSTEPS; j++)
        {
            float3 jPos = iPos + pSun * (jTime + jStepSize * 0.5);
            float jHeight = length(jPos) - rPlanet;
            jOdRlh += exp(-jHeight / shRlh) * jStepSize;
            jOdMie += exp(-jHeight / shMie) * jStepSize;
            jTime += jStepSize;
        }

        float3 attn = exp(-(kMie * (iOdMie + jOdMie) + kRlh * (iOdRlh + jOdRlh)));
        totalRlh += odRlh * attn;
        totalMie += odMie * attn;
        iTime += iStepSize;
    }

    return iSun * (pRlh * kRlh * totalRlh + pMie * kMie * totalMie);
}

// Replace this with your noise function or 3D texture sampling
float Noise3D(float3 p)
{
    // Simplex/perlin noise placeholder
    // Example: Use a pre-existing noise texture or implement Perlin noise
    return frac(sin(dot(p, float3(12.9898, 78.233, 37.719))) * 43758.5453);
}

// Fractal Brownian Motion: sum multiple octaves of noise
float FBM(float3 p, int octaves)
{
    float value = 0;
    float amplitude = 0.5;
    float frequency = 1.0;
    for (int i = 0; i < octaves; i++)
    {
        value += amplitude * Noise3D(p * frequency);
        frequency *= 2.0;
        amplitude *= 0.5;
    }
    return value;
}

// Cloud density using FBM and smoothstep thresholding
float cloudDensity3D(float3 pos, float time, float tLow, float tHigh, float scale, float coverage, int splits)
{
    // Move clouds with time (wind)
    float3 p = pos * scale + float3(0, 0, -time * 0.2);

    float dens = FBM(p, splits);
    dens = saturate(dens - coverage); // threshold coverage
    dens = smoothstep(tLow, tHigh, dens); // smooth falloff between tLow and tHigh

    return dens;
}



float density(float3 pos, float3 offset)
{
    float3 p = pos * 0.0212242 + offset;
    float dens = FBM(p, offset); // whatever your FBM impl is

    float cov = 1.0 - g_Coverage;
    dens *= smoothstep(cov, cov + 0.05, dens);
    return saturate(dens);
}

//float4 renderVolumetricClouds(float3 origin, float3 dir, float3 skyCol)
//{
//    float cov = saturate(g_Coverage * 1.3); // Increased coverage
//    if (cov <= 0)
//        return float4(0, 0, 0, 0);

//    float thickness = saturate(g_Thickness);
//    float scale = lerp(10.0, 0.5, thickness);
//    float densityMul = lerp(0.5, 2.0, thickness);
//    int splits = max(1, (int) (g_CloudSplits + 0.5));

//    const int STEPS = 64;
//    const float STEP_LENGTH = 1.5;
//    //float3 ray = normalize(dir), pos = origin + ray * 2.0;
//    float3 ray = normalize(dir);

//    float tStart = (CLOUD_MIN_HEIGHT - origin.y) / ray.y;
//    tStart = max(tStart, 10.0); // avoid super close clouds

//    float3 pos = origin + ray * tStart;
//    float3 col = 0;
//    float alpha = 0;

//    float tLow = lerp(0.2, 0.1, cov);
//    float tHigh = tLow + 0.25;

//    [loop]
//    for (int i = 0; i < STEPS; i++)
//    {
//        // Optional: make ambient sky-dependent
//        float3 ambientLight = lerp(float3(0.15, 0.17, 0.2), float3(0.3, 0.35, 0.4), saturate(ray.y * 1.5));

//// Pull sun color from LUT or dynamic control
//        float3 sunColor = normalize(g_SunPos.xyz) * g_SunPos.w;
//        sunColor = pow(abs(sunColor), 1.2); // subtle color curve
        
//        pos += ray * STEP_LENGTH;
//        if (pos.y < CLOUD_MIN_HEIGHT || pos.y > CLOUD_MAX_HEIGHT)
//            continue;

//        float d = cloudDensity3D(pos, g_Time, tLow, tHigh, scale, cov, splits) * densityMul;

//        // Shadow pass (even if d is low)
//        float3 sunDir = normalize(g_SunPos.xyz);
//        float shadow = 1.0;
//        float3 shadowPos = pos + sunDir * 0.1;
//        float dShadow = cloudDensity3D(shadowPos, g_Time, tLow, tHigh, scale, cov, splits);
//        shadow *= exp(-saturate(dShadow * 4.0));

//        // Always apply lighting for consistency
//        float fade = smoothstep(CLOUD_MIN_HEIGHT, CLOUD_MIN_HEIGHT + 0.5, pos.y) *
//                     smoothstep(CLOUD_MAX_HEIGHT, CLOUD_MAX_HEIGHT - 0.5, pos.y);
//        d *= fade;

//       // Compute scattering phase
//        float g = 0.76;
//        float mu = dot(ray, sunDir);
//        float g2 = g * g;
//        float phase = (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * mu, 1.5);
//        phase *= 1.5 / (2.0 * PI);

//// Estimate shading from forward/back density along sun
//        float eps = 0.2;
//        float dFront = cloudDensity3D(pos + sunDir * eps, g_Time, tLow, tHigh, scale, cov, splits);
//        float dBack = cloudDensity3D(pos - sunDir * eps, g_Time, tLow, tHigh, scale, cov, splits);
//        float shading = 0.5 + 0.5 * saturate((dFront - dBack) * 4.0);
//        shading = saturate(shading * 1.2); // stronger directionality
//        shading = lerp(0.2, 1.0, shading); // allow deeper shadows
//         // … inside your ray-marching loop, after you calculate sunDir and phase …

//    // calculate sun elevation factor (0 at horizon, 1 overhead)
//        float sunElev = saturate(sunDir.y);

//    // reduce overall sun contribution when sun is low
//    // tweak these values to taste:
//    //   minFactor – lowest multiplier when sun is right on horizon (e.g. 0.2)
//    //   1.0      – full brightness when sun directly overhead
//        float minFactor = 0.2;
//        float sunFactor = lerp(minFactor, 1.0, sunElev);


        
//        float L = shading * phase * g_SunIntensity * shadow * sunFactor;
//        float3 litColor = sunColor * L;
//        float horizonBlend = smoothstep(0.0, 0.2, dir.y);
//        float3 directLight = (ambientLight + sunColor * L) * sunFactor;
//        float3 finalLight = lerp(skyCol.rgb, directLight, horizonBlend);

        
        
        
//// Blend into scene
//        float aSt = d * 0.08;
//        float tr = 1.0 - alpha;
        
//        // Final light is ambient + sunlit part
    
//        // Accumulate with alpha blending
//        col += finalLight * aSt * tr;
     
        
//        alpha += aSt * tr;

//        if (alpha > 0.95)
//            break;
//    }

//    return float4(saturate(col), saturate(alpha));
//}

// Returns entry/exit distances along rayDir from rayOrigin
bool RaySlabIntersect(
    float3 rayOrigin, float3 rayDir,
    float baseY, float topY,
    out float tEnter, out float tExit)
{
    // Solve rayOrigin.y + t*rayDir.y = baseY  ?  t = (baseY - rayOrigin.y)/rayDir.y
    float t0 = (baseY - rayOrigin.y) / rayDir.y;
    float t1 = (topY - rayOrigin.y) / rayDir.y;
    tEnter = min(t0, t1);
    tExit = max(t0, t1);
    return tExit > 0 && tEnter < tExit;
}


float4 renderVolumetricClouds(float3 rayOrigin, float3 rayDir, float3 skyCol)
{
    // 1) define your slab
    static const float CLOUD_BASE = 1500.0;
    static const float CLOUD_TOP = 3500.0;

    // 2) find entry/exit
    float tEnter, tExit;
    if (!RaySlabIntersect(rayOrigin, rayDir, CLOUD_BASE, CLOUD_TOP, tEnter, tExit))
        return float4(skyCol, 1); // no clouds: just sky

    // clamp start at camera
    tEnter = max(tEnter, 0);

    // 3) march between tEnter and tExit
    const int STEPS = 32;
    float stepLen = (tExit - tEnter) / STEPS;
    float3 step = rayDir * stepLen;
    float t = tEnter;

    float trans = 1.0;
    float alpha = 0.0;
    float3 col = float3(0, 0, 0);

    // tweak these to match your look
    float cov = saturate(g_Coverage);
    float thick = lerp(0.0, 15.0, saturate(g_Thickness)); // [0..15]
    float scale = 0.01; // noise scale
    int splits = max(1, (int) (g_CloudSplits + 0.5));
    float tLow = lerp(0.0, 0.8, cov); // push the low?cut higher as cov increases
    float tHigh = min(tLow + 0.2, 1.0); // thickness of the band

    for (int i = 0; i < STEPS; i++, t += stepLen)
    {
        float3 P = rayOrigin + rayDir * t;

        // inside the march
        //float raw = cloudDensity3D(P, g_Time, /*dummy*/0, /*dummy*/1, scale, /*dummy*/0, splits);
        //float dens = smoothstep(tLow, tHigh, raw) * thick * stepLen;
        float3 Pshift = P * scale + float3(0, 0, -g_Time * 0.2);
        float3 warped = Pshift + FBM(Pshift * 0.5, 2) * 10.0; // turbulence
        float raw = FBM(warped, splits);

// Punch holes in cloud volume
        raw -= cov;
        float dens = saturate(raw / (1.0 - cov)); // compress what's left
        dens = pow(dens, 2.0); // sharpen cores
        dens *= thick * stepLen;

        if (dens > 0.001)
        {
            // simple lighting
            float L = saturate(dot(normalize(g_SunPos.xyz), rayDir));
            float3 shade = lerp(float3(0.5, 0.5, 0.6), float3(1, 1, 1), L);

            // front-to-back alpha blend
            float a = dens * trans; // modulate by remaining light
            col += shade * a;
            alpha += a;
            trans *= (1 - dens);
            if (trans < 0.01)
                break;
        }
    }

    // composite over sky
    float3 final = lerp(skyCol, col, alpha);
    return float4(final, alpha);
} //--------------------------------------
// Stars
//--------------------------------------
float3 renderStars(float3 dir)
{
    float n = noise_iq3(dir * 500.0 + g_Time * 0.05); // twinkle
    float bright = pow(saturate(n), 50.0);

    // Fade near horizon
    float horizonFade = smoothstep(0.0, 0.2, dir.y);

    return bright * float3(1.0, 1.0, 1.0) * horizonFade;
}

//--------------------------------------
// Main
//--------------------------------------
PS_OUTPUT main(PS_INPUT i)
{
    PS_OUTPUT o;

#if RENDER_SKY == 1
    // Convert modelPos into a sky-ray direction (X,Z,Y)
    float3 rayDir = normalize(float3(i.modelPos.x, i.modelPos.z, i.modelPos.y));

    // 1) Compute base atmospheric scattering
    float3 skyCol = atmosphere(
        rayDir,
        float3(0, 6372e3, 0),                  // eye position at top of atmosphere
        normalize(g_SunPos.xyz),               // sun direction
        g_SunPos.w,                           // sun intensity
        6371e3, 6471e3,                       // planet radius, atmosphere radius
        float3(5.5e-6, 13e-6, 22.4e-6),       // Rayleigh scattering constants
        21e-6,                                // Mie scattering constant
        8e3, 1.2e3,                          // Rayleigh scale height, Mie scale height
        0.758                               // Mie phase function parameter
    );

    // 2) Add starfield if enabled
#if STARFIELD_ENABLED
    skyCol += renderStars(rayDir);
#endif

    // 3) Add sun disc/glow if enabled by combo
#if ENABLE_SUN == 1
    float sunDot = dot(rayDir, normalize(g_SunPos.xyz));
    float sunMask = smoothstep(0.995, 1.0, sunDot);
    float3 sunColor = float3(1.0, 0.94, 0.82) * g_SunPos.w;
    skyCol += sunColor * sunMask;
#endif
    
    //float3 auroraCol = float3(0,0,0);
    
    if ( g_RenderAurora > 0.5 )
    {
      // Normalize UV coords [0..1]
        float2 uv = i.baseTexCoord;

    // Aspect ratio correction
        float aspect = g_vecfullscreentexel.xy;
        float2 p = uv - 0.5;
        p.x *= aspect;

    // Camera origin and ray direction
        float3 ro = float3(0.0, 0.0, -6.7);
        float3 rd = normalize(float3(p.x, p.y, 1.3));

        float3 auroraCol  = float3(0, 0, 0);
        float fade = smoothstep(0.0, 0.01, abs(rd.y)) * 0.1 + 0.9;

        if (rd.y > 0.0)
        {
        // Aurora & stars (assumes aurora() returns float4 and stars() float3)
            float4 aur = smoothstep(0.0, 1.5, aurora(ro, rd, uv)) * fade;
        //col += stars(rd);
            //auroraCol  = auroraCol  * (1.0 - aur.a) + aur.rgb;
            auroraCol += aur.rgb;
        }
        else
        {
            rd.y = abs(rd.y);
            auroraCol  = auroraCol  * fade * 0.6;
            float4 aur = smoothstep(0.0, 2.5, aurora(ro, rd, uv));
        //col += stars(rd) * 0.1;
            auroraCol  = auroraCol  * (1.0 - aur.a) + aur.rgb;

            float3 pos = ro + ((0.5 - ro.y) / rd.y) * rd;
            float nz2 = triNoise2d(pos.xz * float2(0.5, 0.7), 0.0);
            auroraCol  += lerp(float3(0.2, 0.25, 0.5) * 0.08, float3(0.3, 0.3, 0.5) * 0.7, nz2 * 0.4);
        }
        
        //o.vColor_0 = float4(auroraCol , 1.0);
        skyCol += auroraCol;
    
    }
    
    
    
    // 4) Render volumetric clouds in front of atmosphere
    float4 clouds = renderVolumetricClouds(float3(0, 0.3, 0), rayDir, skyCol);
    float3 col = lerp(skyCol, clouds.rgb, clouds.a);

    // 5) Apply dither (optional)
    float2 pixelPos = i.baseTexCoord * 1024.0;
    col = ApplyDither(col, pixelPos);

    o.vColor_0 = float4(col, 1.0);

    
#else
    o.vColor_0 = float4(0, 0, 0, 1);
#endif
    

    

    // These other render targets remain unchanged
    o.vColor_1 = float4(normalize(i.modelPos) * -1, 1);
    o.vColor_2 = float4(0, 0, 0, 0);
    o.vColor_3 = float4(20, 20, 20, 0);

    return o;
}
