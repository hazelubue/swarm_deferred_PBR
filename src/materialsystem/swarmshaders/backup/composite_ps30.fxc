
// STATIC:		"ALPHATEST"			"0..1"
// STATIC:		"TRANSLUCENT"		"0..1"
// STATIC:		"READNORMAL"		"0..1"
// STATIC:		"NOCULL"			"0..1"
// STATIC:		"PHONGFRESNEL"		"0..1"
// STATIC:		"ENVMAP"			"0..1"
// STATIC:		"ENVMAPMASK"		"0..1"
// STATIC:		"ENVMAPFRESNEL"		"0..1"

// STATIC:		"RIMLIGHT"						"0..1"
// STATIC:		"RIMLIGHTMODULATELIGHT"			"0..1"

// STATIC:		"BASETEXTURE2"		"0..1"
// STATIC:		"BLENDMODULATE"		"0..1"
// STATIC:		"MULTIBLEND"		"0..1"

// STATIC:		"SELFILLUM"					"0..1"
// STATIC:		"SELFILLUM_MASK"			"0..1"
// STATIC:		"SELFILLUM_ENVMAP_ALPHA"	"0..1"

// STATIC:		"BUMPMAP"			"0..1"

// DYNAMIC:		"PIXELFOGTYPE"		"0..1"


// SKIP:		$ALPHATEST && $TRANSLUCENT
// SKIP:		!$ENVMAP && $ENVMAPFRESNEL
// SKIP:		!$ENVMAP && $ENVMAPMASK

// SKIP:		$ENVMAP && !$READNORMAL
// SKIP:		$ENVMAPFRESNEL && !$READNORMAL
// SKIP:		$PHONGFRESNEL && !$READNORMAL
// SKIP:		$RIMLIGHT && !$READNORMAL
// SKIP:		!$RIMLIGHT && $RIMLIGHTMODULATELIGHT

// SKIP:		!$BASETEXTURE2 && !$MULTIBLEND && $BLENDMODULATE
// SKIP:		$MODEL && $BASETEXTURE2
// SKIP:		$MODEL && $MULTIBLEND
// SKIP:		$BASETEXTURE2 && $MULTIBLEND
// SKIP:		$ENVMAPMASK && $MULTIBLEND
// SKIP:		$SELFILLUM_MASK && $MULTIBLEND

// SKIP:		!$SELFILLUM && $SELFILLUM_MASK
// SKIP:		!$SELFILLUM && $SELFILLUM_ENVMAP_ALPHA
// SKIP:		$SELFILLUM_MASK && $SELFILLUM_ENVMAP_ALPHA
// SKIP:		$SELFILLUM_MASK && $ENVMAPMASK
// SKIP:		$SELFILLUM_ENVMAP_ALPHA && !$ENVMAPMASK
// SKIP:		$BUMPMAP && $TRANSLUCENT
// SKIP:		$BUMPMAP && $ALPHATEST

#include "common_ps_fxc.h"
#include "common_deferred_fxc.h"
#include "common_vertexlitgeneric_dx9.h"

#include "pbr_common_ps2_3_x.h"


sampler sAlbedo							: register( s0 );

#if ALPHATEST
const float g_flAlphaRef				: register( c0 );
#endif


sampler sNormals						: register( s1 );

sampler sLightAccum						: register( s2 );

const float2 g_vecFullScreenTexel		: register( c1 );
const float4 g_vecFogParams				: register( c2 );
const float3 g_vecOrigin				: register( c3 );

const float g_flPhongScale				: register( c4 );

#if ENVMAP
sampler sEnvmap								: register( s3 );
const float3 g_flEnvmapTint					: register( c5 );
const float2 g_flEnvmapSaturationContrast	: register( c6 );

#	if ENVMAPMASK
sampler sEnvmapMask							: register( s4 );
#	endif
#endif

#if BASETEXTURE2
sampler sAlbedo2							: register( s5 );
#endif

#if BLENDMODULATE
sampler sBlendmodulate						: register( s6 );
#endif

#if PHONGFRESNEL || ENVMAPFRESNEL
const float3 g_flFresnelRanges				: register( c7 );
#endif

#if RIMLIGHT
const float3 g_flRimLight_Tint						: register( c8 );
const float2 g_flRimLight_Exponent_AlbedoScale		: register( c9 );
#endif

#if ENVMAPMASK && BASETEXTURE2
sampler sEnvmapMask2						: register( s7 );
#endif

#if MULTIBLEND
sampler sAlbedo2							: register( s5 );
sampler sAlbedo3							: register( s7 );
sampler sAlbedo4							: register( s8 );

#if BLENDMODULATE
sampler sBlendmodulate2						: register( s9 );
sampler sBlendmodulate3						: register( s10 );
#endif
#endif

#if SELFILLUM
const float3 g_flSelfIllum_Tint				: register( c10 );
#if SELFILLUM_MASK
sampler sSelfIllumMask						: register( s4 ); // override envmap mask
#endif
#endif

sampler sLightmap : register(s11);
sampler sMRAO     : register(s12);

const float3 cAmbientCube[6]     : register(c11);
const float4 g_DiffuseModulation : register(c12);
const float3 g_EyePos			 : register(c13);

struct PS_INPUT
{
#if BLENDMODULATE
	float4 vTexCoord				: TEXCOORD0;
#else
    float2 vTexCoord : TEXCOORD0;
#endif

	//float3 vProjPosXYW				: TEXCOORD1;
    float3 vWorldPos : TEXCOORD2;

#if ENVMAP || RIMLIGHT || PHONGFRESNEL || ENVMAPFRESNEL
	float3 worldToEye				: TEXCOORD3;
#endif

#if BASETEXTURE2
	float4 vColor_0					: COLOR0;
#endif

#if MULTIBLEND
#if BLENDMODULATE
	float4 vTexCoordBlendmod23			: TEXCOORD4;
#endif
	float3 vAlphaBlend					: TEXCOORD5;
	float4 vColorBlend1					: COLOR0;
	float4 vColorBlend2					: COLOR1;
	float4 vColorBlend3					: TEXCOORD6;
	float3 vColorBlend4					: TEXCOORD7;
#endif

#if NOCULL
	float vDir						: VFACE;
#endif

    float2 vScreenPos : VPOS;
};



struct PS_OUTPUT
{
    float4 vColor_0 : COLOR0;
};

float3 DoIBL(float3 vWorldNormal, float3 vWorldPos, float metallicMap, float roughnessMap, float3 lightmap, in float2 uv)
{
    float3 WorldToEye = g_EyePos.xyz - vWorldPos;
    float3 V = normalize(WorldToEye);
    float3 N = normalize(vWorldNormal);

	//precompute dots
    float NV = max(0.0, dot(normalize(N), V));
	
    float3 metallic = clamp(metallicMap, 0.0f, 0.9f);
	
    float3 albedo = tex2D(sAlbedo, uv);
	
#if ENVMAP == 1

#if CUBEMAPCORRECTED == 0
		float3 reflectVect = CalcReflectionVectorUnnormalized( vWorldNormal, V );
#else
		float3 reflectVect = CalcReflectionVectorUnnormalized( vWorldNormal, WorldToEye);
		float3 BoxSize = float3(g_EnvmapRadius,g_EnvmapRadius,g_EnvmapRadius);
		float3 BoxMax = BoxSize + g_EnvmapOrigin;
		float3 BoxMin = -BoxSize + g_EnvmapOrigin;
		float3 firstPlaneIntersect = (BoxMax - vWorldPos) / reflectVect;
		float3 secondPlaneIntersect = (BoxMin - vWorldPos) / reflectVect;
		float3 furthestPlane = max(firstPlaneIntersect, secondPlaneIntersect);
		float planeDist = min(min(furthestPlane.x, furthestPlane.y), furthestPlane.z);
		float3 intersectPositionWS = vWorldPos + reflectVect * planeDist;
		reflectVect = intersectPositionWS - g_EnvmapOrigin;
#endif

	float4 directionPosX = { 1.0f, 0.01f, 0.01f, 12.0f }; float4 directionNegX = {-1.0f, 0.01f, 0.01f, 12.0f };
	float4 directionPosY = { 0.01f, 1.0f, 0.01f, 12.0f }; float4 directionNegY = { 0.01f,-1.0f, 0.01f, 12.0f };
	float4 directionPosZ = { 0.01f, 0.01f, 1.0f, 12.0f }; float4 directionNegZ = { 0.01f, 0.01f,-1.0f, 12.0f };
	float3 lookupPosX = ENV_MAP_SCALE * texCUBElod(sEnvmap, directionPosX);
	float3 lookupNegX = ENV_MAP_SCALE * texCUBElod(sEnvmap, directionNegX);
	float3 lookupPosY = ENV_MAP_SCALE * texCUBElod(sEnvmap, directionPosY);
	float3 lookupNegY = ENV_MAP_SCALE * texCUBElod(sEnvmap, directionNegY);
	float3 lookupPosZ = ENV_MAP_SCALE * texCUBElod(sEnvmap, directionPosZ);
	float3 lookupNegZ = ENV_MAP_SCALE * texCUBElod(sEnvmap, directionNegZ);
	float3 envmapCube[6] = { lookupPosX, lookupNegX, lookupPosY, lookupNegY, lookupPosZ, lookupNegZ };

	float3 irradiance = lightmap;

	float3 f0 = 0.04f.xxx;
	f0 = lerp(f0, albedo.rgb, metallic);
    float3 F = fresnelSchlickRoughness(NV, f0, roughnessMap); // ambient Lighting Fresnel Term 

	float2 BRDF = EnvBRDFApprox(f0, roughnessMap, NV);

	float3 kD = 1.0f.xxx - F;
	kD *= 1.0 - metallic;	

	float3 diffuseIBL = kD * albedo * irradiance;
	float3 lookup = ENV_MAP_SCALE * texCUBElod(sEnvmap, float4(reflectVect, roughnessMap * 12.0)).rgb;
	float3 specularIrradiance = lerp(lookup, PixelShaderAmbientLight( reflectVect, envmapCube ), roughnessMap * roughnessMap);
	float3 specularIBL = float3(BRDF.xy, 0.0f) * specularIrradiance;

#if CUBEMAPCORRECTED == 1
		float fallof = saturate(length(g_EnvmapOrigin - vWorldPos) / g_EnvmapRadius);
		fallof = 1.0f - pow(fallof, 5.0f);
		specularIBL *= fallof;
#endif

    //mix
    return max(0.0, diffuseIBL + specularIBL);
#else

    float3 albedoSample = tex2D(sAlbedo, uv);
    
    float3 f0 = 0.04f.xxx;
    f0 = lerp(f0, albedoSample.rgb, metallic);
    float3 F = fresnelSchlickRoughness(NV, f0, roughnessMap); // ambient Lighting Fresnel Term 

    float3 kD = 1.0f.xxx - F;
    kD *= 1.0 - metallic;
    return kD * albedoSample * lightmap;
#endif
}


PS_OUTPUT main(const PS_INPUT In)
{
    PS_OUTPUT Out;
	
    Out.vColor_0 = float4(0, 0, 0, 1);
	
    float2 screenPos = (In.vScreenPos + 0.5f) * g_vecFullScreenTexel;
	
    float3 worldNormal;
	
#if READNORMAL
	worldNormal = tex2D( sNormals, screenPos ).xyz * 2.0f - 1.0f;
#endif
	
    worldNormal = tex2D(sNormals, screenPos).xyz * 2.0f - 1.0f;
	
    float3 surfNormal = normalize(worldNormal);
    float3 surfTangent;
    float3 surfBase;
    float flipSign;
    float3x3 normalBasis = ComputeTangentFrame(surfNormal, In.vWorldPos, In.vTexCoord, surfTangent, surfBase, flipSign);
	
    float4 flAlbedoSample = tex2D(sAlbedo, In.vTexCoord.xy);

#if BASETEXTURE2
	float4 flAlbedoSample2 = tex2D( sAlbedo2, In.vTexCoord.xy );
	float flBlendfactor = In.vColor_0.w;
#if BLENDMODULATE
	flBlendfactor = GetModulatedBlend( flBlendfactor, tex2D( sBlendmodulate, In.vTexCoord.zw ).rg );
#endif
	flAlbedoSample = lerp( flAlbedoSample, flAlbedoSample2, flBlendfactor );
#endif

#if MULTIBLEND
	float remaining = 1;
	float4 flBlendFactors;

#if BLENDMODULATE
	flBlendFactors.x = GetMultiBlendModulated( tex2D( sBlendmodulate, In.vTexCoord.zw ).rg, In.vColorBlend1.a, In.vAlphaBlend.x, remaining );
	flBlendFactors.y = GetMultiBlendModulated( tex2D( sBlendmodulate2, In.vTexCoordBlendmod23.xy ).rg, In.vColorBlend2.a, In.vAlphaBlend.y, remaining );
	flBlendFactors.z = GetMultiBlendModulated( tex2D( sBlendmodulate3, In.vTexCoordBlendmod23.zw ).rg, In.vColorBlend3.a, In.vAlphaBlend.z, remaining );
#else
	flBlendFactors.x = GetMultiBlend( In.vColorBlend1.a, remaining );
	flBlendFactors.y = GetMultiBlend( In.vColorBlend2.a, remaining );
	flBlendFactors.z = GetMultiBlend( In.vColorBlend3.a, remaining );
#endif
	flBlendFactors.w = remaining;

	flAlbedoSample = flAlbedoSample * flBlendFactors.x
		+ tex2D( sAlbedo2, In.vTexCoord.xy ) * flBlendFactors.y
		+ tex2D( sAlbedo3, In.vTexCoord.xy ) * flBlendFactors.z
		+ tex2D( sAlbedo4, In.vTexCoord.xy ) * flBlendFactors.w;

	flAlbedoSample.rgb *= In.vColorBlend1.rgb * flBlendFactors.x
		+ In.vColorBlend2.rgb * flBlendFactors.y
		+ In.vColorBlend3.rgb * flBlendFactors.z
		+ In.vColorBlend4.rgb * flBlendFactors.w;
#endif

#if ALPHATEST
	clip( flAlbedoSample.a - g_flAlphaRef );
#endif

#if TRANSLUCENT
	Out.vColor_0.w = flAlbedoSample.a;
#else
	Out.vColor_0.w = 1;
#endif

	//float2 screenPos = GetLightAccumUVs( In.vProjPosXYW, g_vecHalfScreenTexel );

	float4 flLighting = ReadLighting( tex2D( sLightAccum, screenPos ) );

    float3 textureNormal = float3(1, 0, 0); // Default tangent space normal
    float3 normal = float3(0, 0, 0);
	
#if (BUMPMAP == 1)
	textureNormal = tex2D(sNormals, screenPos).xyz * 2.0f - 1.0f; //corrected texcoord
	// World Normal
	normal = normalize(mul(textureNormal, normalBasis));
#elif (BUMPMAP == 2)
	textureNormal = tex2D(NormalTextureSampler, screenPos).xyz; //corrected texcoord
	normal = normalize(normalBasis[0] * textureNormal.xxx + normalBasis[1] * textureNormal.yyy + normalBasis[2] * textureNormal.zzz);
	normal = normalize(mul(normal , normalBasis));
#endif


#if RIMLIGHT || PHONGFRESNEL || ENVMAPFRESNEL
	float3 worldToEye = normalize( In.worldToEye );
	worldNormal = normalize( worldNormal );
#endif

#if PHONGFRESNEL || ENVMAPFRESNEL
	float flFresnel = saturate( Fresnel( worldNormal, worldToEye, g_flFresnelRanges ) );
#endif

#if PHONGFRESNEL
	flLighting.w *= flFresnel;
#endif

	float3 flSpecularLighting = (float3)0;

#if RIMLIGHT
	float dotEyeVec = 1.0f - saturate( dot( worldNormal, worldToEye ) );

	float3 rimLighting = pow( dotEyeVec, g_flRimLight_Exponent_AlbedoScale.x );
	rimLighting *= lerp( 1, flAlbedoSample.rgb, g_flRimLight_Exponent_AlbedoScale.y );
	rimLighting *= g_flRimLight_Tint;
#if RIMLIGHTMODULATELIGHT
	rimLighting *= dot( flLighting.rgb, float3( 0.299f, 0.587f, 0.114f ) );
#endif

	flSpecularLighting += rimLighting;
#endif


#if ENVMAP
	float flSpecularFactor;
#if ENVMAPMASK
	float4 vecEnvmapmaskColor = tex2D( sEnvmapMask, In.vTexCoord.xy );
#if BASETEXTURE2
	vecEnvmapmaskColor = lerp( vecEnvmapmaskColor,
		tex2D( sEnvmapMask2, In.vTexCoord.xy ),
		flBlendfactor );
#endif
	flSpecularFactor = vecEnvmapmaskColor.r;
#else
	flSpecularFactor = flAlbedoSample.a;
#endif

#if RIMLIGHT
	float3 reflectVect = reflect( worldToEye, worldNormal );
#else
	float3 reflectVect = CalcReflectionVectorUnnormalized( worldNormal, In.worldToEye );
#endif

	float3 flCubemap = ENV_MAP_SCALE * texCUBE( sEnvmap, reflectVect ).rgb;
	flCubemap *= flSpecularFactor;
	flCubemap *= g_flEnvmapTint;

#if ENVMAPFRESNEL
	flCubemap *= flFresnel;
#endif

	float3 specularLightingSquared = flCubemap * flCubemap;
	flCubemap = lerp( flCubemap, specularLightingSquared, g_flEnvmapSaturationContrast.y );
	float3 greyScale = dot( flCubemap, float3( 0.299f, 0.587f, 0.114f ) );
	flCubemap = lerp( greyScale, flCubemap, g_flEnvmapSaturationContrast.x );

	flSpecularLighting += flCubemap;
#endif

#if SELFILLUM
	float flSelfIllumAmount;
#if SELFILLUM_MASK
	flSelfIllumAmount = tex2D( sSelfIllumMask, In.vTexCoord.xy ).r;
#elif SELFILLUM_ENVMAP_ALPHA
	flSelfIllumAmount = vecEnvmapmaskColor.a;
#else
	flSelfIllumAmount = flAlbedoSample.a;
#endif
	flLighting.rgb = max( flLighting.rgb,
		flAlbedoSample.rgb * g_flSelfIllum_Tint * flSelfIllumAmount );
#endif

	float flLightScale =
#if DEFCFG_USE_SRGB_CONVERSION
		LINEAR_LIGHT_SCALE;
#else
		GAMMA_LIGHT_SCALE;
#endif

    float3 normal_sampler = tex2D(sNormals, screenPos);
	
    float3 normal_matrix = normalize(mul(textureNormal, normalBasis));
	
//    float3 bakedLighting = float3(0.0, 0.0, 0.0);
//#if !MULTIBLEND
//#if MODEL
//    // Models use ambient cube for baked lighting
//    bakedLighting = AmbientCubeLookup(normal_matrix, cAmbientCube ) * 10.0f;
//#else
//    // Brushes use lightmaps
//    bakedLighting = AmbientLookupLightmap(In.vWorldPos, normal_matrix, textureNormal,
//                                          In.lightmapTexCoord1And2, In.lightmapTexCoord3,
//                                          sLightmap, g_DiffuseModulation).rgb * 10.0f;
//#endif
//#endif

    float3 MRAO = tex2D(sMRAO, screenPos);
	
    float roughness = saturate(MRAO.g);
	float metallic  = saturate(MRAO.r);
	float ao        = saturate(MRAO.b);
	
    float3 F0 = lerp(0.04, flAlbedoSample, metallic);
    float3 kS = F0;
    float3 kD = (1.0 - kS) * (1.0 - metallic);
	
    float3 ibl = DoIBL(normal_matrix, In.vWorldPos, metallic, roughness, flSpecularLighting, screenPos);
	
    Out.vColor_0.xyz = ((flAlbedoSample * flLighting.xyz) + ibl) + flSpecularLighting;
	
#if PIXELFOGTYPE == 0
	float fogAmt = CalcPixelFogFactor( PIXELFOGTYPE, g_vecFogParams, g_vecOrigin, In.vWorldPos, 0 );

	Out.vColor_0.xyz = lerp( Out.vColor_0.xyz, g_LinearFogColor, fogAmt );
#endif

	return Out;
}