// DYNAMIC:		"HAS_SHADOW"		"0..1"

static const float EPSILON = 0.00001;


#include "common_ps_fxc.h"
#include "common_deferred_fxc.h"
#include "common_pbr.h"


sampler sMixedSampler[FREE_LIGHT_SAMPLERS] : register(FIRST_LIGHT_SAMPLER_FXC);
const float4 g_flMixedData[78] : register(FIRST_SHARED_LIGHTDATA_CONSTANT_FXC);

sampler sNormals : register(s0);
sampler sDepth : register(s1);
sampler MRAOSampler : register(s14);
//sampler EmissiveSampler : register(s13);
//sampler BRDFSampler : register(s15);


#if HAS_SHADOW
sampler sShadowDepth : register(s2);
#endif

const float3 g_vecViewOrigin : register(c0);
const float3 g_vecLightVec_Forward : register(c1);

const float4x3 g_matOrtho[2] : register(c2);
const float4 g_vecUVTransform[2] : register(c8);
const float3 g_vecSlopeData[2] : register(c10);
const float4 g_vecFilterConfig_A[2] : register(c12);
const float4 g_vecFilterConfig_B[2] : register(c14);

const float3 g_light_diffuse : register(c16);
const float3 g_light_ambient_high : register(c17);
const float3 g_light_ambient_low_half : register(c18);

float g_GrazingFactor : register(c19);
float g_GrazingPower : register(c20);
float g_SpecularBoost : register(c21);
float g_SpecSizeScale : register(c22);
float3 g_flGIIntensity : register(c23);
float g_flEnableGI : register(c24);
float g_RoughnessScale : register(c25);
float g_shapeBias : register(c26);
float g_DiffuseScale : register(c27);
float g_FresnelPower : register(c28);
float g_SheenStrength : register(c29);
float g_SheenRoughness : register(c30);
float g_MetallicRoughnessFactor : register(c31);



struct PS_INPUT
{
    float2 vTexCoord : TEXCOORD0;
    float3 vecWorldRay : TEXCOORD1;
};

struct PS_OUTPUT
{
    float4 vColor_0 : COLOR0;
};

float3 fresnelSchlickRoughness(float cosTheta, float3 F0, float roughness)
{
    return F0 + (max(1.0f.xxx - F0, F0) - F0) * pow(1.0f - cosTheta, g_FresnelPower) * roughness;
}

float3 fresnelSchlick(float cosTheta, float3 F0)
{
    return F0 + (1.0f.xxx - F0) * pow(1.0f - cosTheta, g_FresnelPower);
}


float DistributionGGX(float3 N, float3 H, float distL, float roughness)
{
    float alphaPrime = saturate(16.0f / (distL * 2.0) + roughness);
    float a = roughness * alphaPrime;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;

    float num = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;

    return num / denom;
}
float CharlieDistribution(float NdotH, float alpha)
{
    float sinThetaH = sqrt(1.0 - NdotH * NdotH);
    float alphaInv = 1.0 / max(alpha, 0.001);
    float exponent = alphaInv;
    float numer = (2.0 + exponent) * pow(sinThetaH, exponent);
    return numer / (2.0 * PI);
}

float3 FresnelSheen(float NV, float3 tint, float strength)
{
    float grazing = pow(1.0 - NV, 5.0);
    return tint * strength * grazing;
}

float3 SheenBRDF_DreamWorks(float3 N, float3 V, float3 L, float3 tint, float strength, float roughness)
{
    const float kMinSheenR = 0.05;
    float sheenRough = max(saturate(roughness), kMinSheenR);

    float3 H = normalize(V + L);
    float NdotH = saturate(dot(N, H));
    float NV = saturate(dot(N, V));

    float D = CharlieDistribution(NdotH, sheenRough);

    float grazing = pow(1.0 - NV, 5.0);
    float3 F = tint * strength * grazing;

    return D * F;
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float num = NdotV;
    float denom = NdotV * (1.0 - roughness) + roughness;

    return num / denom;
}

float GeometrySmith(float3 N, float3 V, float3 L, float roughness)
{
    float r = roughness + 1.0f;
    r = (r * r) / 8.0f;
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2 = GeometrySchlickGGX(NdotV, r);
    float ggx1 = GeometrySchlickGGX(NdotL, r);

    return ggx1 * ggx2;
}

float ndfGGX(float cosNH, float roughness)
{
    float a = roughness * roughness;
    float a2 = a * a;
    float denom = (cosNH * cosNH) * (a2 - 1.0) + 1.0;
    return a2 / (PI * denom * denom);
}

float gaSchlickG1(float cosTheta, float k)
{
    return cosTheta / (cosTheta * (1.0 - k) + k);
}

float gaSchlickGGX(float cosLi, float cosLo, float roughness)
{
    float r = roughness + 1.0;
    float k = (r * r) / 8.0;
    return gaSchlickG1(cosLi, k) * gaSchlickG1(cosLo, k);
}

// Schlick-GGX approximation of geometric attenuation function using Smith's method
// This version remaps the roughness to reduce "hotness", however this should only be used for analytical lights
float GaSchlickGGXRemapped(float cosLi, float cosLo, float roughness)
{
    // k is alpha/2, to better fit the Smith model for GGX
    // Roughness is also remapped using (roughness + 1)/2 before squaring
    //
    // Substituting the remapping, you get:
    //  alpha = ((roughness+1)/2)^2 = (roughness+1)*(roughness+1)/4
    //  k = alpha/2 = (roughness+1)*(roughness+1)/8

    float r = roughness + 1.0;
    float k = (r * r) / 8.0;
    return gaSchlickG1(cosLi, k) * gaSchlickG1(cosLo, k);
}

// Sebastien Lagarde proposes an empirical approach to derive the specular occlusion term from the diffuse occlusion term in [Lagarde14].
// The result does not have any physical basis but produces visually pleasant results.
// See Sebastien Lagarde and Charles de Rousiers. 2014. Moving Frostbite to PBR.
float ComputeSpecularAO(float vDotN, float ao, float roughness)
{
    return clamp(pow(vDotN + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);
}

// Visibility term G( l, v, h )
// Very similar to Marmoset Toolbag 2 and gives almost the same results as Smith GGX
float Visibility_Schlick(half vdotN, half ldotN, float alpha)
{
    float k = alpha * 0.5;

    float schlickL = (ldotN * (1.0 - k) + k);
    float schlickV = (vdotN * (1.0 - k) + k);

    return (0.25 / (schlickL * schlickV));
    //return ( ( schlickL * schlickV ) / ( 4.0 * vdotN * ldotN ) );
}

// see s2013_pbs_rad_notes.pdf
// Crafting a Next-Gen Material Pipeline for The Order: 1886
// this visibility function also provides some sort of back lighting
float Visibility_SmithGGX(half vdotN, half ldotN, float alpha)
{
    // alpha is already roughness^2

    float V1 = ldotN + sqrt(alpha + (1.0 - alpha) * ldotN * ldotN);
    float V2 = vdotN + sqrt(alpha + (1.0 - alpha) * vdotN * vdotN);

    // RB: avoid too bright spots
    return (1.0 / max(V1 * V2, 0.15));
}

float3 calculateLight(float3 lightIn, float3 lightIntensity, float3 lightOut, float3 normal, float3 fresnelReflectance, float3 vWorldPos, float3 vEye, float roughness, float metalness, float lightDirectionAngle, float3 albedo)
{
    float3 L = normalize(lightIn);
    float3 V = normalize(lightOut);
    float3 N = normalize(normal);

    float3 HalfAngle = normalize(L + V);
    float3 H = (dot(HalfAngle, HalfAngle) > 0.0f) ? HalfAngle : N;

    float cosLightIn = max(0.0f, dot(N, L));
    float cosHalfAngle = max(0.0f, dot(N, H));

    float cosDirectAngle = max(0.0f, dot(L, H));

    float HV = max(0.0f, dot(H, V));
    float HL = max(0.0f, dot(H, L));
    float NdotVF = dot(normal, V);
    float NdotV = max(0.0f, dot(normal, V));
    float NV = max(0.0f, dot(N, V));
    float LN = cosLightIn;
    float VoH = max(0.0f, dot(V, H));
    float VdotH = max(0.0f, dot(V, H));
    float NdotL = max(0.0f, dot(N, L));
    float vDotN = max(0.0f, dot(V, N));


    //corrected fresnel with correct values.
    //old implentation caused dark burning spots on any material.
    float3 F = fresnelSchlickRoughness(fresnelReflectance, vDotN, roughness); // was HL //GREAT effects were with cosHalfAngle, caused normal bug. // Specular reflection
    float3 F2 = fresnelSchlickRoughness(fresnelReflectance, NdotV, roughness); // View-dependent term
    float3 F3 = fresnelSchlickRoughness(fresnelReflectance, NdotL, roughness); // was HL //GREAT effects were with cosHalfAngle, caused normal bug. // Light-dependent term

    float alpha = roughness * roughness;

    float D = ndfGGX(cosHalfAngle, roughness);
    // use Sam Pavloc's function.
    float G = Visibility_SmithGGX(NdotV, NdotL, alpha);
    // add specular occlusion for self shadowing.
    //float specAO = ComputeSpecularAO(NdotV, ao, roughness);
    // Calculate geometric attenuation for specular BRDF
    //float G = GaSchlickGGXRemapped(cosLightIn, NdotV, roughness);
    // Diffuse scattering happens due to light being refracted multiple times by a dielectric medium
    // Metals on the other hand either reflect or absorb energ so diffuse contribution is always, zero
    // To be energy conserving we must scale diffuse BRDF contribution based on Fresnel factor & metalness
#if SPECULAR
    // Metalness is not used if F0 map is available
    float3 kd = float3(1, 1, 1) - F;
#else
    //float3 kdF2 = float3(1, 1, 1) - F2;
    float3 kd = (float3(1, 1, 1) - F) * rcp(max(float3(0.1, 0.1, 0.1), float3(1, 1, 1) - F2));
#endif
 
    // composite all of our fresnel, account for size distortion of lights.
    // important that metalness is used here
    float3 Fc = lerp(F, F2 * F3, saturate(roughness * (1.0 - metalness)));

    //compute ambient here once instead of per loop.
    //float3 ambient = g_flMixedData[index + 2].xyz;

    //float groundIntensity = dot(ambient, float3(0.2126, 0.7152, 0.0722));
    //groundIntensity = saturate(groundIntensity);

    //float3 groundColor = albedo * groundIntensity;
    
    //F2 is stable allows for non black spots of specular
    float3 diffuseBRDF = Diffuse_OrenNayar(F, roughness, NV, LN, VoH) * g_DiffuseScale;
    float3 sheenBRDF = SheenBRDF_DreamWorks(N, V, L, albedo, g_SheenStrength, roughness);

    float3 specularBRDF = (Fc * D * G) / max(EPSILON, 4.0f);
    //specularBRDF *= specAO;
    //float3 CompositeAmbient = Ambient;/*DoAmbient( UV, vWorldPos, normal, vEye, roughness, albedo, ambient, groundColor);*/

    //composite everything
    //float3 finalColor = (diffuseBRDF + specularBRDF * g_SpecularBoost + sheenBRDF + CompositeAmbient) * lightIntensity * LN;

    float3 Diffuse, Specular;
    
    Diffuse = (diffuseBRDF + sheenBRDF) * lightIntensity * g_light_diffuse *LN;
    Specular = specularBRDF * g_SpecularBoost * g_light_diffuse * lightIntensity;

    float3 finalColor = Diffuse + Specular;
    
#if LIGHTMAPPED && !FLASHLIGHT
    return specularBRDF * lightIntensity * LN;
#else

    //return the computed pbr light with tone mapping and gamma correction
    return finalColor;

    //old method
    //return (diffuseBRDF + specularBRDF * g_SpecularBoost + sheenBRDF) * lightIntensity * LN;
#endif
}

PS_OUTPUT main(const PS_INPUT In)
{
    PS_OUTPUT Out = (PS_OUTPUT) 0;

    float2 vecTexcoords;
    float3 vecWorldRay;
    float atten;
#if USEWORLDTRANSFORM
	vecTexcoords = In.vecProjXYW.xy / In.vecProjXYW.z;
	vecWorldRay = g_vecFrustumCenter +
		vecTexcoords.x * g_vecFrustumRight +
		vecTexcoords.y * g_vecFrustumUp;
	vecTexcoords = vecTexcoords * float2(0.5f, -0.5f) + 0.5f;
	vecTexcoords += g_vecHalfScreenTexel;
#else
    vecTexcoords = In.vTexCoord;
    vecWorldRay = In.vecWorldRay;
#endif
    float flDepth = tex2D(sDepth, vecTexcoords).x;

#if USEWORLDTRANSFORM
	clip(min(flDepth - 0.1f, DEPTH_RECONSTRUCTION_LIMIT - flDepth));
#else
    clip(min(flDepth - 0.1f, 32256.0f - flDepth));
#endif

    float3 worldPos = g_vecViewOrigin + In.vecWorldRay * flDepth;

    float4 flNormalCtrl = tex2D(sNormals, vecTexcoords);
    float3 flNormal = normalize(flNormalCtrl.xyz * 2.0f - 1.0f);

    float4 mrao = tex2D(MRAOSampler, vecTexcoords).rgba;
    
    float metalness = mrao.r;
    
    bool bHasRealMRAO = (mrao.a > 0.5f);
    float roughness = 0.0;
    if (bHasRealMRAO)
    {
        roughness = mrao.g * 10.0f;
    }
    else
    {
        roughness = mrao.g * 3.33;
    }
    float ao = mrao.b * 2.0f;
    
    float3 fresnelReflectance = mrao.rgb;


    float3 albedo = float3(0.8f, 0.8f, 0.8f); 
    float3 vLightDir = g_vecLightVec_Forward;
    float3 vEye = g_vecViewOrigin;
    float lightRadius = 1000.0f; 

    float3 lightPos = worldPos + vLightDir * lightRadius;
    float3 radiance = g_light_diffuse;

    float shadowMult = 1.0f;
#if HAS_SHADOW
    if (flDepth < DEPTH_RECONSTRUCTION_LIMIT)
    {
        shadowMult = PerformCascadedShadow(
            sShadowDepth, worldPos, g_matOrtho, g_vecUVTransform, g_vecSlopeData,
            g_vecFilterConfig_A, g_vecFilterConfig_B, flNormal, dot(vLightDir, flNormal)
        );
    }
#endif
       
    //float3 pbrLight = DoPBRLight(worldPos, flNormal, albedo, lightPos,
    //                         radiance, vEye, lightRadius,
    //                         metalness.xxx, roughness.xxx);
    
    float3 outgoingLightDirection = normalize(g_vecViewOrigin.xyz - worldPos); // Lo
    float lightDirectionAngle = max(0, dot(flNormal, outgoingLightDirection)); // cosLo

    float3 LightIn = g_vecLightVec_Forward;
    float3 LightColor = float3(1.0, 1.0, 1.0);
	
    float viewFwdDot = dot(g_vecLightVec_Forward.xyz, flNormal);
    
    float litDot = lerp(viewFwdDot, viewFwdDot * 0.5f + 0.5f, 0.0f);
    float lightAmount = saturate(litDot);
 
    float3 F0 = lerp(0.04f.xxx, albedo, metalness);
    float3 directLighting = calculateLight(LightIn, LightColor, outgoingLightDirection,
                    flNormal, F0, worldPos, g_vecViewOrigin, roughness, metalness, lightDirectionAngle, albedo);

    //float viewFwdDot = dot(g_vecLightVec_Forward, flNormal);
    //viewFwdDot = saturate(viewFwdDot);
    
    float3 ambient = lerp(g_light_ambient_low_half, g_light_ambient_high, viewFwdDot);
    float3 finalColor = directLighting;
    
    float3 ambientLight = lerp(ambient, radiance * litDot, lightAmount);
    float3 combinedLighting = (finalColor + ambientLight) * shadowMult;
    Out.vColor_0 = float4(combinedLighting, 1.0f);
    
    return Out;
}
