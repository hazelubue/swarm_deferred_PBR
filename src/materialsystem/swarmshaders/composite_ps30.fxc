// STATIC:		"ALPHATEST"			"0..1"
// STATIC:		"TRANSLUCENT"		"0..1"
// STATIC:		"READNORMAL"		"0..1"
// STATIC:		"NOCULL"			"0..1"
// STATIC:		"PHONGFRESNEL"		"0..1"
// STATIC:		"ENVMAP"			"0..1"
// STATIC:		"ENVMAPMASK"		"0..1"
// STATIC:		"ENVMAPFRESNEL"		"0..1"

// STATIC:		"RIMLIGHT"						"0..1"
// STATIC:		"RIMLIGHTMODULATELIGHT"			"0..1"

// STATIC:		"BASETEXTURE2"		"0..1"
// STATIC:		"BLENDMODULATE"		"0..1"
// STATIC:		"MULTIBLEND"		"0..1"

// STATIC:		"SELFILLUM"					"0..1"
// STATIC:		"SELFILLUM_MASK"			"0..1"
// STATIC:		"SELFILLUM_ENVMAP_ALPHA"	"0..1"

// DYNAMIC:		"PIXELFOGTYPE"				"0..1"

// SKIP:		$ALPHATEST && $TRANSLUCENT
// SKIP:		!$ENVMAP && $ENVMAPFRESNEL
// SKIP:		!$ENVMAP && $ENVMAPMASK

// SKIP:		$ENVMAP && !$READNORMAL
// SKIP:		$ENVMAPFRESNEL && !$READNORMAL
// SKIP:		$PHONGFRESNEL && !$READNORMAL
// SKIP:		$RIMLIGHT && !$READNORMAL
// SKIP:		!$RIMLIGHT && $RIMLIGHTMODULATELIGHT

// SKIP:		!$BASETEXTURE2 && !$MULTIBLEND && $BLENDMODULATE
// SKIP:		$MODEL && $BASETEXTURE2
// SKIP:		$MODEL && $MULTIBLEND
// SKIP:		$BASETEXTURE2 && $MULTIBLEND
// SKIP:		$ENVMAPMASK && $MULTIBLEND
// SKIP:		$SELFILLUM_MASK && $MULTIBLEND

// SKIP:		!$SELFILLUM && $SELFILLUM_MASK
// SKIP:		!$SELFILLUM && $SELFILLUM_ENVMAP_ALPHA
// SKIP:		$SELFILLUM_MASK && $SELFILLUM_ENVMAP_ALPHA
// SKIP:		$SELFILLUM_MASK && $ENVMAPMASK
// SKIP:		$SELFILLUM_ENVMAP_ALPHA && !$ENVMAPMASK

#include "common_ps_fxc.h"
#include "common_deferred_fxc.h"
#include "common_vertexlitgeneric_dx9.h"
#include "shader_constant_register_map.h"

#include "pbr_common_ps2_3_x.h"

#define GAMMA 2.2

sampler sAlbedo : register(s0);

#if ALPHATEST
const float g_flAlphaRef				: register( c0 );
#endif

sampler sNormals : register(s1);

sampler sLightAccum : register(s2);

const float2 g_vecFullScreenTexel : register(c20);
const float4 g_vecFogParams : register(c2);
const float3 g_vecOrigin : register(c3);

const float g_flPhongScale : register(c4);


sampler sEnvmap : register(s3);
const float3 g_flEnvmapTint : register(c5);
const float2 g_flEnvmapSaturationContrast : register(c6);

#if ENVMAPMASK
sampler sEnvmapMask							: register( s4 );
#endif

#if BASETEXTURE2
sampler sAlbedo2							: register( s5 );
#endif

#if BLENDMODULATE
sampler sBlendmodulate						: register( s6 );
#endif

#if PHONGFRESNEL || ENVMAPFRESNEL
const float3 g_flFresnelRanges				: register( c7 );
#endif

#if RIMLIGHT
const float3 g_flRimLight_Tint						: register( c8 );
const float2 g_flRimLight_Exponent_AlbedoScale		: register( c9 );
#endif

#if ENVMAPMASK && BASETEXTURE2
sampler sEnvmapMask2						: register( s7 );
#endif

#if MULTIBLEND
sampler sAlbedo2							: register( s5 );
sampler sAlbedo3							: register( s7 );
sampler sAlbedo4							: register( s8 );

#if BLENDMODULATE
sampler sBlendmodulate2						: register( s9 );
sampler sBlendmodulate3						: register( s10 );
#endif
#endif

#if SELFILLUM
const float3 g_flSelfIllum_Tint				: register( c10 );
#if SELFILLUM_MASK
sampler sSelfIllumMask						: register( s4 ); // override envmap mask
#endif
#endif

sampler sMRAO : register(s11);
sampler sLightmap : register(s12);

float4 g_vShaderControls : register(c12);
float4x4 viewInv : register(c13);
float g_iblintensity : register(c24);

#define g_fWriteDepthToAlpha g_vShaderControls.y

struct PS_INPUT
{
#if BLENDMODULATE
	float4 vTexCoord				: TEXCOORD0;
#else
    float2 vTexCoord : TEXCOORD0;
#endif

	//float3 vProjPosXYW				: TEXCOORD1;
    float3 vWorldPos : TEXCOORD2;

#if ENVMAP || RIMLIGHT || PHONGFRESNEL || ENVMAPFRESNEL
	float3 worldToEye				: TEXCOORD3;
#endif

#if BASETEXTURE2
	float4 vColor_0					: COLOR0;
#endif

#if MULTIBLEND
#if BLENDMODULATE
	float4 vTexCoordBlendmod23			: TEXCOORD4;
#endif
	float3 vAlphaBlend					: TEXCOORD5;
	float4 vColorBlend1					: COLOR0;
	float4 vColorBlend2					: COLOR1;
	float4 vColorBlend3					: TEXCOORD6;
	float3 vColorBlend4					: TEXCOORD7;
#endif
    //float4 lightmapTexCoord1And2 : TEXCOORD1;
    //float4 lightmapTexCoord3 : TEXCOORD7;
#if NOCULL
	float vDir							: VFACE;
#endif

    float2 vScreenPos : VPOS;
};


struct PS_OUTPUT
{
    float4 vColor_0 : COLOR0;
};

float3 IBLAmbientRadiance(float3 N, float3 V, float roughness, float metallic, float3 albedo, float3 F0, float3 EnvPrefilterMap, float3 EnvIrrMap)
{
    float3 worldN = mul(viewInv, float4(N, 0)).xyz; // World normal
    float3 worldV = mul(viewInv, float4(V, 0)).xyz; // World view
    float Nworld = worldV.xyz;
	
    float3 irradiance = pow(float4(EnvIrrMap, Nworld).xyz, (float3) GAMMA);

    // cos(angle) between surface normal and eye
    float NdV = max(0.001, dot(worldN, worldV));
    float3 kS = fresnelSchlickRoughness(NdV, F0, roughness);
    float3 kD = 1.0 - kS;

    float3 diffuseBrdf = albedo * (1.0 - metallic); // Lambert diffuse
    float3 diffuse = kD * diffuseBrdf * irradiance;

    const float MAX_REFLECTION_LOD = 6.0;
    float3 R = reflect(-worldV, worldN);
 
    float mipLevel = roughness * MAX_REFLECTION_LOD;
	
    float rMip = float4(R, mipLevel);
	
    float4 prefilteredColor = float4(EnvPrefilterMap, rMip);
    float3 specular = prefilteredColor.xyz * (kS);

    return (diffuse + specular);
}

PS_OUTPUT main(const PS_INPUT In)
{
    PS_OUTPUT Out;

    float4 flAlbedoSample = tex2D(sAlbedo, In.vTexCoord.xy);
	
#if USEENVAMBIENT && ENVMAP
    float3 EnvAmbientCube[6];
    setupEnvMapAmbientCube(EnvAmbientCube, sEnvmap);
#else
#define EnvAmbientCube cAmbientCube
#endif
	
#if BASETEXTURE2
	float4 flAlbedoSample2 = tex2D( sAlbedo2, In.vTexCoord.xy );
	float flBlendfactor = In.vColor_0.w;
#if BLENDMODULATE
	flBlendfactor = GetModulatedBlend( flBlendfactor, tex2D( sBlendmodulate, In.vTexCoord.zw ).rg );
#endif
	flAlbedoSample = lerp( flAlbedoSample, flAlbedoSample2, flBlendfactor );
#endif

#if MULTIBLEND
	float remaining = 1;
	float4 flBlendFactors;

#if BLENDMODULATE
	flBlendFactors.x = GetMultiBlendModulated( tex2D( sBlendmodulate, In.vTexCoord.zw ).rg, In.vColorBlend1.a, In.vAlphaBlend.x, remaining );
	flBlendFactors.y = GetMultiBlendModulated( tex2D( sBlendmodulate2, In.vTexCoordBlendmod23.xy ).rg, In.vColorBlend2.a, In.vAlphaBlend.y, remaining );
	flBlendFactors.z = GetMultiBlendModulated( tex2D( sBlendmodulate3, In.vTexCoordBlendmod23.zw ).rg, In.vColorBlend3.a, In.vAlphaBlend.z, remaining );
#else
	flBlendFactors.x = GetMultiBlend( In.vColorBlend1.a, remaining );
	flBlendFactors.y = GetMultiBlend( In.vColorBlend2.a, remaining );
	flBlendFactors.z = GetMultiBlend( In.vColorBlend3.a, remaining );
#endif
	flBlendFactors.w = remaining;

	flAlbedoSample = flAlbedoSample * flBlendFactors.x
		+ tex2D( sAlbedo2, In.vTexCoord.xy ) * flBlendFactors.y
		+ tex2D( sAlbedo3, In.vTexCoord.xy ) * flBlendFactors.z
		+ tex2D( sAlbedo4, In.vTexCoord.xy ) * flBlendFactors.w;

	flAlbedoSample.rgb *= In.vColorBlend1.rgb * flBlendFactors.x
		+ In.vColorBlend2.rgb * flBlendFactors.y
		+ In.vColorBlend3.rgb * flBlendFactors.z
		+ In.vColorBlend4.rgb * flBlendFactors.w;
#endif

#if ALPHATEST
	clip( flAlbedoSample.a - g_flAlphaRef );
#endif

#if TRANSLUCENT
	Out.vColor_0.w = flAlbedoSample.a;
#else
    Out.vColor_0.w = 1;
#endif

    float2 screenPos = (In.vScreenPos + 0.5f) * g_vecFullScreenTexel;
	
    float4 flLighting = (float4) 0;
    float4 flLightmap = (float4) 0;
    flLightmap = tex2D(sLightmap, screenPos);
    flLighting = ReadLighting(tex2D(sLightAccum, screenPos));
	
    flLighting += flLightmap;

#if READNORMAL
	float3 worldNormal = tex2D( sNormals, screenPos ).xyz * 2.0f - 1.0f;
#else
    float3 worldNormal = tex2D(sNormals, screenPos).xyz * 2.0f - 1.0f;
#endif
	
    float3 textureNormal = tex2D(sNormals, screenPos).xyz;
	
#if NOCULL
    worldNormal *= In.vDir;
#endif

#if RIMLIGHT || PHONGFRESNEL || ENVMAPFRESNEL
	float3 worldToEye = normalize( In.worldToEye );
	worldNormal = normalize( worldNormal );
#endif

#if PHONGFRESNEL || ENVMAPFRESNEL
	float flFresnel = saturate( Fresnel( worldNormal, worldToEye, g_flFresnelRanges ) );
#endif

#if PHONGFRESNEL
	flLighting.w *= flFresnel;
#endif

    float3 flSpecularLighting = (float3) 0;

#if RIMLIGHT
	float dotEyeVec = 1.0f - saturate( dot( worldNormal, worldToEye ) );

	float3 rimLighting = pow( dotEyeVec, g_flRimLight_Exponent_AlbedoScale.x );
	rimLighting *= lerp( 1, flAlbedoSample.rgb, g_flRimLight_Exponent_AlbedoScale.y );
	rimLighting *= g_flRimLight_Tint;
#if RIMLIGHTMODULATELIGHT
	rimLighting *= dot( flLighting.rgb, float3( 0.299f, 0.587f, 0.114f ) );
#endif

	flSpecularLighting += rimLighting;
#endif

    float3 MRAO = tex2D(sMRAO, screenPos);

    float roughness = MRAO.g;
    float metallic = MRAO.r;

    float3 V = normalize(g_vecOrigin.xyz - In.vWorldPos);
    float3 N = normalize(worldNormal);
    float NdotV = max(0.0f, dot(N, V));

#if ENVMAP
	float flSpecularFactor;
#if ENVMAPMASK
	float4 vecEnvmapmaskColor = tex2D( sEnvmapMask, In.vTexCoord.xy );
#if BASETEXTURE2
	vecEnvmapmaskColor = lerp( vecEnvmapmaskColor,
		tex2D( sEnvmapMask2, In.vTexCoord.xy ),
		flBlendfactor );
#endif
	flSpecularFactor = vecEnvmapmaskColor.r;
#else
	flSpecularFactor = flAlbedoSample.a;
#endif

#if RIMLIGHT
	float3 reflectVect = reflect( -V, N );
#else
	float3 reflectVect = CalcReflectionVectorUnnormalized( N, normalize(In.worldToEye) );
#endif

	// IBL Prefiltering
	const int SAMPLE_COUNT = 12;
	float totalWeight = 0.0;   
	float3 prefilteredColor = float3(0.0, 0.0, 0.0);
	float A = 0.0;
	float B = 0.0;
	
	float3 sampleColor = (float3) 0;
	
	[unroll(12)]
	for(int i = 0; i < SAMPLE_COUNT; ++i)
	{
		float2 Xi = Hammersley(i, 1024);
		float3 H = ImportanceSampleGGX(Xi, N, roughness);
		float3 L = normalize(2.0 * dot(V, H) * H - V);
		
		float NdotL = max(dot(N, L), 0.0);
		float NdotH = max(dot(N, H), 0.0);
		float VdotH = max(dot(V, H), 0.0);
		
		if(NdotL > 0.0)
		{
			sampleColor = texCUBE(sEnvmap, L).rgb;
			prefilteredColor += sampleColor * NdotL;
			totalWeight += NdotL;
			
			float G = GeometrySmith(N, V, L, roughness);
			float G_Vis = (G * VdotH) / (NdotH * NdotV);
			float Fc = pow(1.0 - VdotH, 5.0);
			
			A += (1.0 - Fc) * G_Vis;
			B += Fc * G_Vis;
		}
	}
	
	A /= float(SAMPLE_COUNT);
	B /= float(SAMPLE_COUNT);
	
	// Compute final envmap contribution
	float3 flCubemap = (prefilteredColor / max(totalWeight, 0.001)) * ENV_MAP_SCALE;
	
	flCubemap *= flSpecularFactor;
	flCubemap *= g_flEnvmapTint;
	
#if ENVMAPFRESNEL
	flCubemap *= flFresnel;
#endif
	
	float3 specularLightingSquared = flCubemap * flCubemap;
	flCubemap = lerp( flCubemap, specularLightingSquared, g_flEnvmapSaturationContrast.y );
	float3 greyScale = dot( flCubemap, float3( 0.299f, 0.587f, 0.114f ) );
	flCubemap = lerp( greyScale, flCubemap, g_flEnvmapSaturationContrast.x );
	
	// apply split-sum approx
	float3 F0 = float3(0.04, 0.04, 0.04);
	float3 F = F0 + (1.0 - F0) * pow(1.0 - NdotV, 5.0);
	float3 kS = F * A + B;
	float3 kD = (1.0 - kS) * (1.0 - metallic);
	
	flSpecularLighting += flCubemap * kS;
	
	float3 AmbientIBL = (float3) 0;
	AmbientIBL = IBLAmbientRadiance(N, V, roughness, metallic, flAlbedoSample.xyz, F0, flSpecularLighting, flCubemap) * g_iblintensity;
	
	flSpecularLighting += AmbientIBL;

#endif

#if SELFILLUM
	float flSelfIllumAmount;
#if SELFILLUM_MASK
	flSelfIllumAmount = tex2D( sSelfIllumMask, In.vTexCoord.xy ).r;
#elif SELFILLUM_ENVMAP_ALPHA
	flSelfIllumAmount = vecEnvmapmaskColor.a;
#else
	flSelfIllumAmount = flAlbedoSample.a;
#endif
	flLighting.rgb = max( flLighting.rgb,
		flAlbedoSample.rgb * g_flSelfIllum_Tint * flSelfIllumAmount );
#endif

    float flLightScale =
#if DEFCFG_USE_SRGB_CONVERSION
		LINEAR_LIGHT_SCALE;
#else
		GAMMA_LIGHT_SCALE;
#endif

//    float alpha = flAlbedoSample.a;
	
//    float3 result = (float3) 0;
	
//    float fogFactor;
//    float flVertexFogFactor = 0.0f;
	
//    fogFactor = CalcPixelFogFactorSupportsVertexFog(PIXELFOGTYPE, g_vecFogParams, g_vecOrigin.xyz, In.worldPos_projPosZ.xyz, In.worldPos_projPosZ.w, flVertexFogFactor);
	
//    if (PIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT && WRITEWATERFOGTODESTALPHA)
//    {
//        alpha = fogFactor;
//    }
	
//    result += float4(((flAlbedoSample.xyz + flLighting.w * g_flPhongScale) * flLighting.xyz
//		+ flSpecularLighting) * flLightScale, 0.0);
	
//    Out.vColor_0.xyzw = float4(result.rgb, alpha);
	
//#if PIXELFOGTYPE == 0
//	Out.vColor_0.xyz = lerp( Out.vColor_0.xyz, g_LinearFogColor, fogFactor );
//#endif
	
    Out.vColor_0.xyzw = float4(((flAlbedoSample.xyz + flLighting.w * g_flPhongScale) * flLighting.xyz
		+ flSpecularLighting) * flLightScale, flAlbedoSample.a);

#if PIXELFOGTYPE == 0
	float fogAmt = CalcPixelFogFactor( PIXELFOGTYPE, g_vecFogParams, g_vecOrigin, In.vWorldPos, 0 );

	Out.vColor_0.xyz = lerp( Out.vColor_0.xyz, g_LinearFogColor, fogAmt );
#endif

    return Out;
}